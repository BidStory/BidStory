<script src="/BidStory/js/dataBase/dbManager.js"></script>

<script>
    // âœ… Ù…ØµÙÙˆÙØ§Øª Ø¹Ø§Ù…Ø© Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const allDatabaseNames = [];              // Ù„ØªØ¬Ù…ÙŠØ¹ Ø£Ø³Ù…Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const allProcessNames = [];              // Ù„ØªØ¬Ù…ÙŠØ¹ Ø£Ø³Ù…Ø§Ø¡ ÙƒÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª (Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©)
    const itemsPerProcess = {};              // Ù„ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ©: Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ§Ø¨Ø¹Ø© Ù„Ù‡Ø§
    const dbsPerItem = {};                   // Ù„ÙƒÙ„ Ø¹Ù†ØµØ±: Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡

    // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø«Ù… Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
    async function checkAndAddDatabase(dbName) {
        if (await checkDatabaseExists(dbName)) {
            allDatabaseNames.push(dbName);
            return true;
        }
        return false;
    }

    // âœ… Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª "allPro"
    async function fetchAllProcesses() {
        const dbName = "allPro";
        const processKeys = [];

        if (!(await checkAndAddDatabase(dbName))) return processKeys;

        const db = new noUpgrade(dbName);
        const rows = await db.getAllDataFromTable("rows");

        if (Array.isArray(rows)) {
            for (const row of rows) {
                if (row?.key !== undefined) {
                    processKeys.push(row.key.toString());
                }
            }
        } else {
            console.warn("âš ï¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ allPro ØºÙŠØ± ØµØ§Ù„Ø­Ø©:", rows);
        }

        return processKeys;
    }

    // âœ… Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†Ø§ØµØ± (items) Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø¹Ù…Ù„ÙŠØ© Ù…Ø¹ÙŠÙ†Ø©
    async function fetchItemsForProcess(processKey) {
        const items = [];
        const relatedDBs = [];

        const defDB = `def_${processKey}`;
        const iteDB = `ite_${processKey}`;

        if (await checkAndAddDatabase(defDB)) relatedDBs.push(defDB);

        if (await checkAndAddDatabase(iteDB)) {
            relatedDBs.push(iteDB);
            const db = new noUpgrade(iteDB);
            const rows = await db.getAllDataFromTable("rows");

            if (Array.isArray(rows)) {
                for (const row of rows) {
                    if (row?.key !== undefined) {
                        const itemKey = row.key.toString();
                        items.push(itemKey);

                        // âœ… Ø¬Ù„Ø¨ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¹Ù†ØµØ±
                        const itemDBs = await fetchDatabasesForItem(itemKey);
                        relatedDBs.push(...itemDBs);
                    }
                }
            }
        }

        return { items, relatedDBs };
    }

    // âœ… Ø¬Ù„Ø¨ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø¹Ù†ØµØ± Ù…Ø¹ÙŠÙ† (item)
    async function fetchDatabasesForItem(itemKey) {
        const itemDBs = [];
        const staticSections = [
            "raw", "equipments", "labor", "transport", "other",
            "cond", "files", "Timeline"
        ];

        // âœ… Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø§Ù„Ø¹Ù†ØµØ±
        for (const section of staticSections) {
            const dbName = `${section}_${itemKey}`;
            if (await checkAndAddDatabase(dbName)) {
                itemDBs.push(dbName);
            }
        }

        // âœ… Ù‚ÙˆØ§Ø¹Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…ØªÙƒØ±Ø±Ø© (bill_x_itemKey)
        let i = 1;
        while (i <= 1000) {
            const billDB = `bill_${i}_${itemKey}`;
            const exists = await checkDatabaseExists(billDB);
            if (!exists) break;

            allDatabaseNames.push(billDB);
            itemDBs.push(billDB);

            const db = new noUpgrade(billDB);
            const rows = await db.getAllDataFromTable("rows");

            // âœ… Ù‚ÙˆØ§Ø¹Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ù‚Ø³Ø§Ù… ÙƒÙ„ ÙØ§ØªÙˆØ±Ø©
            if (Array.isArray(rows)) {
                for (const row of rows) {
                    if (row?.key !== undefined) {
                        const billSections = [
                            "PandBillNo", "PandBillLength", "PandBillWidth",
                            "PandBillHight", "PandBillKg", "PandBillPrice", "PandBillPercent"
                        ];
                        for (const section of billSections) {
                            const sectionDB = `${row.key}__n_${section}`;
                            if (await checkAndAddDatabase(sectionDB)) {
                                itemDBs.push(sectionDB);
                            }
                        }
                    }
                }
            }

            i++;
        }

        // âœ… ØªØ®Ø²ÙŠÙ† Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¹Ù†ØµØ±
        dbsPerItem[itemKey] = [...itemDBs];

        return itemDBs;
    }

    // âœ… Ø¬Ù„Ø¨ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: Ø¹Ù…Ù„ÙŠØ§Øª + Ø¹Ù†Ø§ØµØ± + Ù‚ÙˆØ§Ø¹Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª
    async function getAllDatabaseStructure() {
        // âœ… ØªÙ‡ÙŠØ¦Ø© ÙƒÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù„ØªÙƒÙˆÙ† Ù†Ø¸ÙŠÙØ©
        allDatabaseNames.length = 0;
        allProcessNames.length = 0;
        Object.keys(itemsPerProcess).forEach(key => delete itemsPerProcess[key]);
        Object.keys(dbsPerItem).forEach(key => delete dbsPerItem[key]);

        const processes = await fetchAllProcesses();

        for (const processKey of processes) {
            allProcessNames.push(processKey);
            const processData = await fetchItemsForProcess(processKey);
            itemsPerProcess[processKey] = processData;
        }

        console.log("âœ… Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:", allDatabaseNames);
        console.log("ğŸ“Œ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª:", allProcessNames);
        console.log("ğŸ§© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù„ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ©:", itemsPerProcess);
        console.log("ğŸ“¦ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙƒÙ„ Ø¹Ù†ØµØ±:", dbsPerItem);

        return {
            allDatabaseNames: [...allDatabaseNames],
            allProcessNames: [...allProcessNames],
            itemsPerProcess: { ...itemsPerProcess },
            dbsPerItem: { ...dbsPerItem }
        };
    }

    // âœ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù…Ù„ÙŠØ© ÙˆØ§Ø­Ø¯Ø© Ø­Ø³Ø¨ Ø§Ø³Ù…Ù‡Ø§
    async function getSingleProcessData(processKey) {
        if (!processKey || typeof processKey !== "string") {
            console.warn("âš ï¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø¹Ù…Ù„ÙŠØ© ØµØ§Ù„Ø­");
            return null;
        }

        allDatabaseNames.length = 0;

        const result = {
            process: processKey,
            items: [],
            relatedDatabases: [],
            databasesPerItem: {}
        };

        const allProExists = await checkDatabaseExists("allPro");
        if (!allProExists) {
            console.warn("âŒ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª 'allPro' ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©");
            return null;
        }

        // âœ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ "allPro"
        const db = new noUpgrade("allPro");
        const rows = await db.getAllDataFromTable("rows");
        const processFound = rows?.some(row => row?.key?.toString() === processKey);
        if (!processFound) {
            console.warn("âŒ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©:", processKey);
            return null;
        }

        // âœ… Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙˆÙ‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
        const data = await fetchItemsForProcess(processKey);
        result.items = data.items;
        result.relatedDatabases = data.relatedDBs;

        for (const item of data.items) {
            result.databasesPerItem[item] = dbsPerItem[item] || [];
        }

        console.log("ğŸ“ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:", result);
        return result;
    }

    // âœ… ØªÙ†ÙÙŠØ° Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ø¬Ø©
    (async () => {
        await getAllDatabaseStructure();                      // Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„ Ù„ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      //  await getSingleProcessData("yzQe1750303300564");     // Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ù…Ù„ÙŠØ© Ù…Ø­Ø¯Ø¯Ø©
    })();
</script>
